name: "dbt Jobs"
description: "Run dbt CI / merge / deploy jobs as a composite action"

branding:
  icon: "play-circle"
  color: "purple"

inputs:
  type:
    description: "Job type: ci, merge, or deploy"
    required: true
  adapter:
    description: "dbt adapter short name (currently: snowflake)"
    required: true
  command:
    description: "dbt commands to run (multi-line supported)"
    required: true
  project-dir:
    description: "Path to the dbt project root"
    required: false
    default: "."
  profile-dir:
    description: "Directory containing profiles.yml"
    required: false
    default: "."
  deferral:
    description: "Branch to fetch production manifest from"
    required: false
    default: ""
  target:
    description: "dbt target to use"
    required: false
    default: ""
  run-timeout:
    description: "Timeout in seconds per command (0 = unlimited)"
    required: false
    default: "0"
  dbt-version:
    description: "dbt-core version (empty or 'latest' = auto-resolve)"
    required: false
    default: ""
  threads:
    description: "Number of dbt threads"
    required: false
    default: ""
  source-freshness:
    description: "Run 'dbt source freshness'"
    required: false
    default: "false"
  post-pr-comment:
    description: "Post build results as PR comment (ci only)"
    required: false
    default: "false"
  ci-schema-prefix:
    description: "Schema prefix for CI. Sets SNOWFLAKE_SCHEMA to <prefix>_<PR number>."
    required: false
    default: "dbt_pr_job"

runs:
  using: "composite"
  steps:
    # ---- Step 1: Validate type ----
    - name: Validate type
      shell: bash
      env:
        INPUT_TYPE: ${{ inputs.type }}
      run: |
        if [[ "$INPUT_TYPE" != "ci" && "$INPUT_TYPE" != "merge" && "$INPUT_TYPE" != "deploy" ]]; then
          echo "::error::Invalid type '${INPUT_TYPE}'. Must be one of: ci, merge, deploy"
          exit 1
        fi

    # ---- Step 1.5: Override schema for CI ----
    - name: Override schema for CI
      if: inputs.type == 'ci' && inputs.ci-schema-prefix != ''
      shell: bash
      env:
        CI_SCHEMA_PREFIX: ${{ inputs.ci-schema-prefix }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
      run: |
        if [[ -z "$PR_NUMBER" ]]; then
          echo "::error::ci-schema-prefix requires a pull_request event"
          exit 1
        fi
        schema="${CI_SCHEMA_PREFIX}_${PR_NUMBER}"
        if [[ "$schema" == *$'\n'* ]]; then
          echo "::error::Schema name must not contain newlines"
          exit 1
        fi
        echo "SNOWFLAKE_SCHEMA=${schema}" >> "$GITHUB_ENV"
        echo "CI schema: ${schema}"

    # ---- Step 2: Setup dbt ----
    - name: Validate and normalize adapter
      id: normalize-adapter
      shell: bash
      env:
        INPUT_ADAPTER: ${{ inputs.adapter }}
      run: |
        adapter="$INPUT_ADAPTER"
        adapter="${adapter#dbt-}"
        adapter="${adapter,,}"

        case "$adapter" in
          snowflake)
            echo "adapter_package=dbt-snowflake" >> "$GITHUB_OUTPUT"
            ;;
          *)
            echo "::error::Unsupported adapter: ${INPUT_ADAPTER}. Supported adapters: snowflake"
            exit 1
            ;;
        esac

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.11"

    - name: Install uv
      uses: astral-sh/setup-uv@v7

    - name: Resolve dbt version
      id: resolve-dbt-version
      shell: bash
      env:
        ACTION_PATH: ${{ github.action_path }}
        DBT_VERSION_INPUT: ${{ inputs.dbt-version == 'latest' && '' || inputs.dbt-version }}
        DBT_PROJECT_DIR: ${{ inputs.project-dir }}
      run: |
        version=$("${ACTION_PATH}/scripts/resolve-version.sh" \
          "$DBT_VERSION_INPUT" \
          "$DBT_PROJECT_DIR")
        echo "version=$version" >> "$GITHUB_OUTPUT"

    - name: Install dbt
      id: install-dbt
      shell: bash
      env:
        DBT_VERSION: ${{ steps.resolve-dbt-version.outputs.version }}
        DBT_ADAPTER_PACKAGE: ${{ steps.normalize-adapter.outputs.adapter_package }}
      run: |
        if [[ -n "$DBT_VERSION" ]]; then
          uv pip install --system "dbt-core==${DBT_VERSION}" "${DBT_ADAPTER_PACKAGE}"
        else
          uv pip install --system dbt-core "${DBT_ADAPTER_PACKAGE}"
        fi

        installed_version=$(dbt --version | grep -oP 'installed: \K[0-9]+\.[0-9]+\.[0-9]+' | head -1 || dbt --version | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
        echo "dbt-version=${installed_version}" >> "$GITHUB_OUTPUT"

    # ---- Step 3: dbt deps ----
    - name: dbt deps
      shell: bash
      env:
        DBT_PROJECT_DIR: ${{ inputs.project-dir }}
        DBT_PROFILE_DIR: ${{ inputs.profile-dir }}
      run: |
        dbt deps --project-dir "$DBT_PROJECT_DIR" --profiles-dir "$DBT_PROFILE_DIR"

    # ---- Step 4: Download manifest ----
    - name: Download production manifest
      if: inputs.deferral != ''
      id: download-manifest
      uses: actions/github-script@v8
      env:
        DEFERRAL_BRANCH: ${{ inputs.deferral }}
      with:
        script: |
          const fs = require('fs');
          const branch = process.env.DEFERRAL_BRANCH;

          const runs = await github.rest.actions.listWorkflowRunsForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            branch,
            status: 'success',
            per_page: 5,
          });

          let artifact = null;
          for (const run of runs.data.workflow_runs) {
            const arts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: run.id,
            });
            artifact = arts.data.artifacts.find(a => a.name === 'dbt-artifacts' && !a.expired);
            if (artifact) break;
          }

          if (!artifact) {
            core.warning(`Artifact "dbt-artifacts" not found on branch "${branch}"`);
            core.setOutput('found', 'false');
            return;
          }

          const download = await github.rest.actions.downloadArtifact({
            owner: context.repo.owner,
            repo: context.repo.repo,
            artifact_id: artifact.id,
            archive_format: 'zip',
          });

          fs.writeFileSync('prod-manifest.zip', Buffer.from(download.data));
          core.setOutput('found', 'true');
      continue-on-error: true

    # ---- Step 5: Extract manifest ----
    - name: Extract production manifest
      if: steps.download-manifest.outputs.found == 'true'
      shell: bash
      run: |
        mkdir -p prod-manifest
        unzip -o prod-manifest.zip -d prod-manifest
        rm prod-manifest.zip

    # ---- Step 6: Execute commands ----
    - name: Execute dbt commands
      id: dbt-run
      shell: bash
      env:
        DBT_COMMAND: ${{ inputs.command }}
        DBT_PROFILES_DIR: ${{ inputs.profile-dir }}
        DBT_PROJECT_DIR: ${{ inputs.project-dir }}
        DBT_TARGET: ${{ inputs.target }}
        DBT_THREADS: ${{ inputs.threads }}
        DBT_TIMEOUT: ${{ inputs.run-timeout }}
        DBT_TYPE: ${{ inputs.type }}
        DBT_DEFERRAL: ${{ inputs.deferral }}
        DBT_MANIFEST_FOUND: ${{ steps.download-manifest.outputs.found }}
      run: |
        build_failed=0

        run_dbt_command() {
          local cmd="$1"
          CMD="$cmd" python3 - <<'PY'
        import os
        import shlex
        import subprocess
        import sys

        ALLOWED = frozenset({
            "build", "run", "test", "seed", "snapshot",
            "compile", "parse", "deps", "ls", "list",
            "source", "freshness", "show", "retry", "clone",
        })

        cmd = os.environ.get("CMD", "")
        timeout_text = os.environ.get("DBT_TIMEOUT", "0")
        profiles_dir = os.environ.get("DBT_PROFILES_DIR", "")
        project_dir = os.environ.get("DBT_PROJECT_DIR", "")
        target = os.environ.get("DBT_TARGET", "")
        threads = os.environ.get("DBT_THREADS", "")
        deferral = os.environ.get("DBT_DEFERRAL", "")
        manifest_found = os.environ.get("DBT_MANIFEST_FOUND", "")

        try:
            timeout = int(timeout_text)
        except ValueError:
            print(f"::error::run-timeout must be an integer, got: {timeout_text}")
            sys.exit(2)

        if timeout < 0:
            print(f"::error::run-timeout must be >= 0, got: {timeout}")
            sys.exit(2)

        try:
            args = shlex.split(cmd, posix=True)
        except ValueError as exc:
            print(f"::error::Invalid command syntax: {exc}")
            sys.exit(2)

        if not args or args[0] != "dbt":
            print("::error::Only dbt commands are allowed.")
            sys.exit(2)

        subcmd = next((a for a in args[1:] if not a.startswith("-")), None)
        if subcmd is None or subcmd not in ALLOWED:
            print(f"::error::Subcommand not allowed: {subcmd or '(none)'}")
            sys.exit(2)

        if profiles_dir and "--profiles-dir" not in args:
            args += ["--profiles-dir", profiles_dir]
        if project_dir and "--project-dir" not in args:
            args += ["--project-dir", project_dir]
        if target and "--target" not in args:
            args += ["--target", target]
        if threads and "--threads" not in args:
            args += ["--threads", threads]
        has_state_selector = any("state:" in a for a in args)

        if deferral and manifest_found == "true" and has_state_selector and "--defer" not in args:
            args += ["--defer", "--state", "./prod-manifest"]
        elif has_state_selector and manifest_found != "true":
            print("::warning::No production manifest found. Removing state: selectors and running full build.")
            args = [a for a in args if "state:" not in a]
            # Clean up empty --select / --exclude flags
            cleaned = []
            skip_next = False
            for i, a in enumerate(args):
                if skip_next:
                    skip_next = False
                    continue
                if a in ("--select", "--exclude", "-s") and (i + 1 >= len(args) or args[i + 1].startswith("-")):
                    continue
                cleaned.append(a)
            args = cleaned

        print(f"Running: {' '.join(shlex.quote(a) for a in args)}")

        try:
            completed = subprocess.run(args, check=False, timeout=(timeout or None))
            sys.exit(completed.returncode)
        except subprocess.TimeoutExpired:
            print(f"::error::Command timed out after {timeout} seconds")
            sys.exit(124)
        PY
        }

        while IFS= read -r line; do
          line="$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
          [[ -z "$line" || "$line" == \#* ]] && continue

          echo "::group::$line"
          run_dbt_command "$line" && rc=0 || rc=$?
          echo "::endgroup::"

          if [[ $rc -ne 0 ]]; then
            if [[ "$DBT_TYPE" == "ci" ]]; then
              build_failed=1
              echo "::warning::Command failed (exit $rc): $line"
            else
              exit $rc
            fi
          fi
        done <<< "$DBT_COMMAND"

        echo "build-failed=$build_failed" >> "$GITHUB_OUTPUT"

    # ---- Step 7: Source freshness ----
    - name: dbt source freshness
      if: inputs.source-freshness == 'true'
      shell: bash
      env:
        DBT_PROFILE_DIR: ${{ inputs.profile-dir }}
        DBT_PROJECT_DIR: ${{ inputs.project-dir }}
        DBT_TARGET: ${{ inputs.target }}
        DBT_THREADS: ${{ inputs.threads }}
      run: |
        cmd=(dbt source freshness)
        cmd+=(--profiles-dir "$DBT_PROFILE_DIR")
        cmd+=(--project-dir "$DBT_PROJECT_DIR")
        if [[ -n "$DBT_TARGET" ]]; then
          cmd+=(--target "$DBT_TARGET")
        fi
        if [[ -n "$DBT_THREADS" ]]; then
          cmd+=(--threads "$DBT_THREADS")
        fi
        "${cmd[@]}"

    # ---- Step 8: Upload artifacts ----
    - name: Upload artifacts
      if: inputs.type == 'merge' || inputs.type == 'deploy'
      uses: actions/upload-artifact@v6
      with:
        name: dbt-artifacts
        path: |
          ${{ inputs.project-dir }}/target/manifest.json
          ${{ inputs.project-dir }}/target/run_results.json
        retention-days: 90

    # ---- Step 10: PR comment ----
    - name: Post PR comment
      if: >-
        always()
        && inputs.type == 'ci'
        && inputs.post-pr-comment == 'true'
        && github.event_name == 'pull_request'
        && steps.dbt-run.outcome == 'success'
      uses: actions/github-script@v8
      env:
        DBT_COMMAND: ${{ inputs.command }}
        DBT_PROJECT_DIR: ${{ inputs.project-dir }}
        BUILD_FAILED: ${{ steps.dbt-run.outputs.build-failed }}
      with:
        script: |
          const fs = require('fs');
          const path = require('path');

          const projectDir = process.env.DBT_PROJECT_DIR;
          const runResultsPath = path.join(projectDir, 'target', 'run_results.json');
          const buildFailed = process.env.BUILD_FAILED === '1';
          const command = process.env.DBT_COMMAND;

          let body = '';

          if (fs.existsSync(runResultsPath)) {
            const results = JSON.parse(fs.readFileSync(runResultsPath, 'utf8'));
            const stats = { pass: 0, warn: 0, error: 0, skip: 0 };
            for (const r of results.results) {
              const status = r.status.toLowerCase();
              if (status === 'pass' || status === 'success') stats.pass++;
              else if (status === 'warn') stats.warn++;
              else if (status === 'error' || status === 'fail') stats.error++;
              else stats.skip++;
            }

            const icon = stats.error > 0 ? ':x:' : ':white_check_mark:';
            body = [
              `## ${icon} dbt Build Results`,
              '',
              '**Command:**',
              '```',
              command.trim(),
              '```',
              '',
              '| Status | Count |',
              '|--------|-------|',
              `| :white_check_mark: Pass | ${stats.pass} |`,
              `| :warning: Warn | ${stats.warn} |`,
              `| :x: Error | ${stats.error} |`,
              `| :fast_forward: Skip | ${stats.skip} |`,
              '',
              '<details><summary>Details</summary>',
              '',
              '| Node | Status | Time |',
              '|------|--------|------|',
              ...results.results.map(r => {
                const statusIcon = (r.status === 'pass' || r.status === 'success') ? ':white_check_mark:' : r.status === 'error' || r.status === 'fail' ? ':x:' : ':warning:';
                return `| \`${r.unique_id}\` | ${statusIcon} ${r.status} | ${r.execution_time.toFixed(2)}s |`;
              }),
              '',
              '</details>',
            ].join('\n');
          } else {
            const status = buildFailed ? 'failure' : 'success';
            body = `## :warning: dbt Build\n\nNo run results found. Build status: **${status}**`;
          }

          const marker = '<!-- dbt-jobs -->';
          body = `${marker}\n${body}`;

          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });

          const existing = comments.find(c => c.body.startsWith(marker));
          if (existing) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: existing.id,
              body,
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body,
            });
          }

    # ---- Step 11: Check build result ----
    - name: Check build result
      if: >-
        always()
        && inputs.type == 'ci'
        && steps.dbt-run.outcome == 'success'
      shell: bash
      env:
        BUILD_FAILED: ${{ steps.dbt-run.outputs.build-failed }}
      run: |
        if [[ "$BUILD_FAILED" == "1" ]]; then
          echo "::error::dbt build failed"
          exit 1
        fi
